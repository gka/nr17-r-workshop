---
title: "Workshop: Statistische Daten und Wahlergebnisse als Bar-Codes visualisieren"
output:
  html_document: default
  html_notebook: default
---


## 1. Daten laden

Zum laden der Daten benutzen wir das `readr` Package. readr stellt eine ganze Reihe von Befehlen bereit.

```{r}
needs(readr, dplyr)
```

Zunächst werden wir die (zuvor bereinigten) Wahlergebnisse laden. Dazu benutzen wir die `read_tsv` Funktion vom `readr` Paket. Wir speichern das Ergebnis in der Variable `btw`.

```{r}
btw <- read_tsv('data/cleaned/btw09_kerg.csv')
```

**Tipp:** oben rechts im "Environment" Panel zeigt RStudio alle angelegten Variablen und Tabellen. Per Klick lässt sich unsere Tabelle `btw` anschauen.

```{r}
btw <- read_tsv('data/cleaned/btw09_kerg.csv') %>% 
  select(Nr, Wahlkreis, Land,
         CDU=CDU.Zweitstimmen,
         SPD=SPD.Zweitstimmen,
         CSU=CSU.Zweitstimmen,
         FDP=FDP.Zweitstimmen,
         GRÜNE=GRÜNE.Zweitstimmen,
         LINKE=`DIE LINKE.Zweitstimmen`)
```

**Tipp:** Mit der Hilfefunktion in RStudio können wir mehr über alle Befehle erfahren. Dazu einfach den Eingabe-Cursor irgendwo auf das Wort "select" setzen und die F1 Taste drücken.

## 2. Stimmen der beiden politischen Blöcke berechnen

Um neue Spalten zu berechnen benutzen wir das Paket `dplyr` (Link für später: [Introduction to dplyr](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html))

Aus den Zweitstimmen der großen Parteien berechnen wir nun die Gesamtstimmen zweier Blöcke: SPD + LINKE + GRÜNE (RRG) sowie Schwarz-Gelb (SG)

Gesamtstimmen der Koalitionen Rot-Rot-Grün (RRG) und CDU/CSU+FDP (SG) berechnen:
  
```{r}
btw_koal <- btw %>%
  mutate(RRG=SPD + GRÜNE + LINKE,
         SG=CDU + CSU + FDP)
```

Schauen wir uns das Ergebnis an fällt auf das wir immer nur `NA` bei Schwarz-Gelb erhalten. Woran liegt das?

CDU uns CSU sind niemals gleichzeitig definiert. Was wir brauchen ist eine Funktion die automatisch entweder den CDU oder CSU Wert benutzt, je nach dem welcher definiert ist. Die `coalesce` Funktion macht genau das:

```{r}
btw_koal <- btw %>%
  mutate(RRG=SPD + GRÜNE + LINKE,
         SG=coalesce(CDU, CSU) + FDP)
```


# 3. Prozentuale Stimmendifferenz berechnen:
  
1. margin = `100 * (SG - RRG)/(SG + RRG)`
2. sieger
3. landslide, wenn margin 10 Prozent oder mehr
4. klasse

```{r}
btw_margin <- btw_koal %>% 
  # lege ein neues feld "margin" an
  mutate(margin=round(100 * (SG - RRG)/(SG + RRG), 2)) %>% 
  # lege ein neues feld "winner" an
  mutate(winner=ifelse(SG > RRG, 'SG', 'RRG')) %>% 
  # lege ein neues feld "landslide" an
  mutate(landslide=abs(margin) >= 10) %>% 
  # lege ein neues feld "gruppe" an
  mutate(gruppe=paste0(ifelse(landslide,'L_','C_'), winner)) %>% 
  # sortiere die gruppen
  mutate(gruppe=factor(gruppe, c('L_SG', 'C_SG', 'C_RRG', 'L_RRG')))
```

kjkjk

```{r}
table(btw_margin$landslide)
table(btw_margin$landslide, btw_margin$winner)
```

Wiederholen mit Wahlergebnissen früherer Wahlen!

## 4. Mit Strukturdaten kombinieren

Strukturdaten dazuladen und per left_join verbinden:
  
```{r}
btw_struktur <- read_tsv('data/cleaned/btw13_strukturdaten.csv') %>%
  select(-Wahlkreis) %>% 
  filter(Nr < 300)
```

und per `left_join` verbinden
  
```{r}
btw_final <- btw_margin %>% 
  left_join(btw_struktur, by ='Nr')
```

```{r}
btw_final %>% write_csv('btw-final.csv')
```



## 5. Visualisierung

```{r}
needs(ggplot2)
theme_set(theme_minimal())
```


```{r}
plot_data <- btw_final %>%
  select(landslide, gruppe, wert=Mit.Hochschulreife)

plot_data %>% 
  ggplot(aes(x=wert, y=gruppe, color=gruppe)) +
  geom_point()
```

Mit `scale_colour_manual` können wir unsere eigenen Farben auswählen:

```{r}
colors <- c(L_SG='#333333', C_SG='#777777', L_RRG='#cc0000', C_RRG='#dd7777')

plot_data %>% 
  ggplot(aes(x=wert, y=gruppe, color=gruppe)) +
  geom_point() +
  scale_colour_manual(values = colors)
```


### Bar-Codes

Statt `geom_point` benutzen wir nun `geom_vline`.

```{r, fig.height=2, fig.width=8}
plot_data %>% 
  ggplot() +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.35) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10()
```

Mit `facet_grid` kann man aus jedem Plot ganz einfach Small multiples machen:

```{r, fig.height=3, fig.width=8}
plot_data %>% 
  ggplot() +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.35) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10() +
  facet_grid(gruppe ~ .)

# introduction: facet_grid
#  gruppe ~ .    . ~ gruppe    landslide ~ sieger
```


Nur "landslide" Wahlkreise:

```{r, fig.height=2, fig.width=8}
plot_data %>% 
  filter(landslide) %>% 
  ggplot(aes(wert)) +
  facet_grid(gruppe ~ .) +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.35) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10()
```

Mittelwerte hinzufügen:

```{r, fig.height=2, fig.width=8}
mittel <- plot_data %>% 
  group_by(gruppe) %>% 
  summarize(avg=mean(wert), med=median(wert))

plot_data2 <- left_join(plot_data, mittel, 'gruppe')

plot_data2 %>% 
  filter(landslide) %>% 
  ggplot() +
  facet_grid(gruppe ~ .) +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.25) +
  geom_vline(aes(xintercept=avg), color='black', size=2, alpha=1) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10()
```

das ganze können wir in einer funktion speichern:

```{r, fig.height=3, fig.width=8}
plot_bars <- function(spalte, log=FALSE) {
  
  plot_data <- btw_final %>% 
    filter(landslide) %>% 
    select_('winner', 'gruppe', wert=as.name(spalte)) %>% 
    mutate(wert=wert)

  mittel <- plot_data %>% 
    group_by(gruppe) %>% 
    summarize(avg=mean(wert), med=median(wert))
  
  plot <- plot_data %>% 
    left_join(mittel, 'gruppe') %>% 
    ggplot(aes(wert)) +
    facet_grid(gruppe ~ .) +
    geom_vline(aes(xintercept=wert + rnorm(nrow(plot_data), sd = 0.1), color=gruppe), size=1.5, alpha=0.25) +
    geom_vline(aes(xintercept=avg), color='white', size=5, alpha=0.7) +
    geom_vline(aes(xintercept=avg), color='black', size=1, alpha=1) +
    scale_colour_manual(values = colors, guide=F) +
    ggtitle(spalte) + xlab('')
    theme(plot.margin = rep(unit(0.5,'cm'),4))
  
  if (log) plot <- plot + scale_x_log10()
  plot
}
```


```{r, fig.height=2, fig.width=8}
# plot_bars('Bevölkerungsdichte', log=TRUE)
plot_bars('Mit.Hochschulreife')
```

und lassen die funktion automatisch über alle Spalten in unserem Datensatz laufen. Das Ergebnis speichern wir als PDF Datei mit je 7 Plots pro Seite:

```{r}
needs(gridExtra)

plots <- lapply(colnames(btw_final)[10:47], plot_bars)
plots <- marrangeGrob(plots, nrow=7, ncol=1)
ggsave("plots.pdf", plots, width=21, height=27.9, units='cm')
```
