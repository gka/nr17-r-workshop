---
title: "Workshop: Statistische Daten und Wahlergebnisse als Barcodes visualisieren"
output:
  html_document:
    css: styles.css
    toc: true
    toc_float: false
    theme: cosmo
    highlight: tango
    number_sections: true
---

> _"make a hundred charts and pick one"_ 
>      --- Amanda Cox

# Daten einlesen

Zunächst laden wir die benötigten R-Pakete. `readr` stellt Funktionen 
zum einlesen von CSV Dateien bereit, `dplyr` liefert praktische 
Werkzeuge zum analysieren und transformieren von Tabellen, und 
`ggplot2` ist das Visualisierungs-Framework das wir heute benutzen.

Die folgenen Code Blöcke (genannt "chunks") lassen sich in RStudio
durch Klick auf den grünen Pfeil oben rechts im Block ausführen.

```{r setup}
needs(readr, dplyr, ggplot2)

# falls das nicht klappt, muss needs noch installiert werden
# install.packages('needs')
# library(needs)

theme_set(theme_light())
```

Nun laden wir den im ersten Teil vorbereiteten Datensatz 
`btw-final.csv` und speichern ihn in der Variable `btw`. Die `mutate`
Anweisung in der zweiten Zeile können wir erstmal ignorieren.

Nach dem Ausführen des Blocks erscheint oben links im "Environment" 
Fenster ein neuer Eintrag "btw". Durch klick auf den Eintrag können
wir uns den geladenen Datensatz genauer ansehen.

```{r daten einlesen}
btw <- read_csv('btw-final.csv') %>% 
  mutate(gruppe=factor(gruppe, c('L_SG', 'C_SG', 'C_RRG', 'L_RRG')))
```

# Fingerübungen mit ggplot

Kommen wir zum spannenden Teil. Daten visualisieren mit `ggplot2`. Die
Syntax ist etwas gewöhnungsbedürftig, aber sehr mächtig wenn man
erstmal den Dreh raus hat.

Die Funktion `ggplot()` macht allein erst mal nichts, außer einen
leeren Plot zu erstellen und ihm einen Datensatz zuzuordnen.

```{r leerer plot, fig.height=2}
ggplot(btw)
```

Über den zweiten Parameter `mapping` kann man Spalten aus dem 
Datensatz zu  sogenannten "aesthetics" zuordnen, wie z.B. `x`, `y` 
oder `color`. ggplot erstellt dann ggf. schon automatisch Achsen und
Gitternetzlinien.

```{r nur achsen}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD))
```

Um nun Datenpunkte auf den Plot zu bekommen müssen wir weitere Ebenen
zum Plot hinzufügen. Dazu "addieren" wir weitere ggplot-Funktionen zu
dem Ergebnis des ersten `ggplot()` Aufrufs. In diesem Fall wollen wir
Punkte, also benutzen wir `geom_point()`:

```{r schwarze punkte}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point()
```

Jede ggplot Funktion hat selbst eine Reihe von Parametern über die
das Aussehen der Plot-Ebene angepasst werden kann.

Im Falle von `geom_point` lassen sich Form, Farbe, Größe und viele 
weitere visuelle Eigenschaften der Symbole ändern (für eine Liste
aller möglichen Parameter können wir die Hilfefunktion benutzen):

```{r rote dreiecke}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(color='red', shape=2)
```

Anstatt die Eigenschaften nur "statisch" für alle Punkte gleichermaßen
zu verändern kann man auch weitere Spalten aus dem Datensatz verwenden
und so neue Dimensionen zu dem Plot hinzufügen. 

Im folgenden Beispiel färben wir die Symbole je nach dem Wert der
Spalte _landslide_, und wir machen die Symbolgröße abhängig von dem 
Wert in der Spalte _Ohne.Hauptschulabschluss_.

```{r bubble plot}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(aes(color=landslide, size=Ohne.Hauptschulabschluss), alpha=0.5)
```

Man kann auch noch weitere Ebenen zum Plot hinzufügen, indem man noch mal `geom_point()` hinzufügt und die `y` aesthetic überschreibt.

Hier fügen wir pro Wahlkreis noch einen weiteren Punkt zum Plot hinzu
aber benutzen das CDU Wahlergebnis für die y-Koordinaten: 

```{r roten punkte und schwarze kreuze}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(color='red') +
  geom_point(aes(y=CDU), color='black', shape=3)
```

Da wir feststellen dass sich fast alle Punkte sich an den linken Rand des Plots
drängen, bietet sich vielleicht eine logarithmische x-Achse an. Und 
auch das können wir mit einer weiteren "Addition" dem Plot hinzufügen:

```{r plot mit log scale}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(color='red') +
  geom_point(aes(y=CDU), color='black', shape=3) +
  scale_x_log10()
```

Wie wäre es mit Trend-Linien für unsere beiden Punktmengen? Kein 
Problem mit der ggplot-Funktion `geom_smooth`. Der Parameter 
`method='lm'` legt fest das wir eine lineare Trendlinie möchten, und
mit `se=FALSE` schalten wir den grauen Hintergrund für das
Vertrauensinterval ab.

```{r plot mit trendlinien}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(color='red') +
  geom_point(aes(y=CDU), color='black', shape=3) +
  geom_smooth(method='lm', color='red', se=FALSE) +
  geom_smooth(aes(y=CDU), method='lm', color='black', se=FALSE) +
  scale_x_log10()
```

Oder wie wäre es mit vertikalen Linien die die für jeden Wahlkreis
beiden Punkte verbinden? Dazu können wir z.B. die Funktion 
`geom_linerange` verwenden, der wir nur die Parameter `ymin` und
`ymax` mitteilen müssen.

```{r vertikale linien}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(color='red') +
  geom_point(aes(y=CDU), color='black') +
  geom_linerange(aes(ymin=SPD, ymax=CDU, color=winner), alpha=0.3) +
  scale_x_log10()
```

Es kommt noch besser: mit `facet_grid` können wir den Plot in mehrere Panels unterteilen, z.b. nach landslide Wahlkreisen und nicht-landslide Wahlkreisen:

```{r split plot mit trendlinien}
ggplot(btw, aes(x=Bevölkerungsdichte, y=SPD)) +
  geom_point(color='red') +
  geom_point(aes(y=CDU), color='black') +
  geom_linerange(aes(ymin=SPD, ymax=CDU, color=winner), alpha=0.3) +
  scale_x_log10() +
  facet_grid(. ~ landslide)
```

Wir wir sehen sind die Möglichkeiten fast endlos. Doch nun zurück 
zu dem was wir eigentlich machen wollten: Barcodes!

# Barcodes visualisieren!

Barcodes sind nichts anderes als vertikale Linien, also fangen wir an
mit `geom_vline`. geom_vline benötigt die aesthetic `xintercept`, die
wir erstmal auf die Spalte _Bevölkerungsdichte_ mappen.

```{r bunte barcodes, fig.height=2, fig.width=8}
ggplot(btw) +
  geom_vline(aes(xintercept=Bevölkerungsdichte, color=gruppe))
```

Zunächst mal möchten wir bessere Farben benutzen, damit wir die 
Gruppen besser lesen können. Dazu definieren wir zunächst ein paar
Farben unserer Wahl (schwarz für schwarz-gelb und rot für rot-rot-grün) 
und fügen diese dann per `scale_colour_manual` dem Plot hinzu:

```{r schwarz rote barcodes, fig.height=2, fig.width=8}
mycolors <- c(L_SG='#333333', C_SG='#999999', L_RRG='#cc0000', C_RRG='#ee9999')

ggplot(btw) +
  geom_vline(aes(xintercept=Bevölkerungsdichte, color=gruppe)) +
  scale_colour_manual(values = mycolors)
```

Leider ist immer noch alles etwas zu unübersichtlich im Plot. 
Also benutzen wir wieder unseren Freund `facet_grid()`, um die 
Barcodes in vier Gruppen zu gliedern. 

Mit `guide=FALSE` schalten wir in `scale_colour_manual()` die Farblegende ab, die nun überflüssig geworden ist.

```{r barcodes mit facet grid, fig.asp=0.4}
ggplot(btw) +
  geom_vline(aes(xintercept=Bevölkerungsdichte, color=gruppe)) +
  scale_colour_manual(values = mycolors, guide=FALSE) +
  facet_grid(gruppe ~ .)
```

Natürlich können wir auch hier wieder eine logarithmische
Achse benutzen, in dem wir die `scale_x_log10()` hinzufügen:

```{r barcodes mit log scale, fig.asp=0.4}
ggplot(btw) +
  geom_vline(aes(xintercept=Bevölkerungsdichte, color=gruppe)) +
  scale_colour_manual(values = mycolors, guide=FALSE) +
  facet_grid(gruppe ~ .) +
  scale_x_log10()
```

Die grauen Ränder um den Plot können wir entfernen in dem wir das
`theme_minimal()` verwenden:

```{r barcodes mit theme_minimal, fig.asp=0.4}
ggplot(btw) +
  geom_vline(aes(xintercept=Bevölkerungsdichte, color=gruppe)) +
  scale_colour_manual(values = mycolors, guide=FALSE) +
  facet_grid(gruppe ~ .) +
  scale_x_log10() +
  theme_minimal()
```

Damit wir in Zukunft nicht jedes Mal wieder das Theme hinzufügen müssen,
setzen wir es jetzt mit `theme_set()` als neues Standard-Theme fest:

```{r minimal theme}
theme_set(theme_minimal())
```

Um unseren Plot abzuschließen möchten wir an den jeweiligen
Mittelwerte des angezeigten Wertes für die verschiedenen Gruppen noch zusätzliche Linen hinzufügen. 

Dazu berechnen wir zunächst die Gruppenmittelwerte mit den _dplyr_ 
Funktionen `group_by` und `summarize`. Anschließend können wir die
neuen Linien durch addieren eines weiteren `geom_vline()` 
Aufrufs zum Plot hinzufügen.

```{r barcodes mit mittelwerten, fig.asp=0.4}
mittelwerte <- btw %>% 
  group_by(gruppe) %>% 
  summarize(mittel=mean(Bevölkerungsdichte))

ggplot(btw) +
    geom_vline(aes(xintercept=Bevölkerungsdichte, color=gruppe)) +
    scale_colour_manual(values = mycolors, guide=FALSE) +
    facet_grid(gruppe ~ ., drop=T) +
    scale_x_log10() +
    geom_vline(aes(xintercept=mittel), data=mittelwerte, 
               color='blue', size=1.5)
```

Jetzt ist unser Plot soweit erstmal fertig!

# Plot als eigene Funktion wiederverwenden

Mit ein bisschen mehr Arbeit können wir den gesamten bisherigen Code
in einer Funktion verpacken, der wir den Namen der zu  visualisierenden
Spalte übergeben können:

```{r barcode funktion, fig.asp=0.4}
barcode_plot <- function(spalte) {
  
  data <- btw %>% 
    filter(landslide) %>% 
    select_('gruppe', wert=as.name(spalte))
  
  mittelwerte <- data %>% 
    group_by(gruppe) %>% 
    summarize(mittel=mean(wert))

  data %>% 
    mutate(wert2=wert+rnorm(nrow(data), 0, 0.02)) %>%  # a little jittering
    ggplot() +
      geom_vline(aes(xintercept=wert2, color=gruppe)) +
      scale_colour_manual(values = mycolors, guide=FALSE) +
      facet_grid(gruppe ~ ., drop=T) +
      geom_vline(aes(xintercept=mittel), data=mittelwerte, 
                 color='blue', size=1.5) +
      ggtitle('', subtitle=paste0(spalte, '\n')) +
      xlab('') +
      theme(strip.text = element_text(size=7),
            plot.margin = margin(0,5,3,5,'mm'))
}
```

Nun können wir die Funktion wie folgt aufrufen:

```{r funktion aufrufen, fig.asp=0.3}
barcode_plot('Arbeitslosenquote')
# barcode_plot('Bergbau')
```

# PDF mit allen Barcode Varianten speichern

Und als krönenden Abschluss können wir mit wenigen weiteren Zeilen 
Code ein PDF mit Barcodes von allen Spalten in unserem Datensatz
erzeugen.

Zunächst stellen wir sicher, das das Paket `gridExtra` geladen wird:

```{r pdf 1}
needs(gridExtra)
```

Dann legen wir einen Vektor von Spaltennamen an, die sich für die
Visualisierung als Barcode eignen:

```{r pdf spalten}
spalten <- colnames(btw)[18:55]
```

Mit `lapply` führen wir unsere `barcode_plot` Funktion dann mit einem
Rutsch für alle Spalten in unserem Vektor auf. Wir leiten das Ergebnis
direkt in die `marrangeGrob` Funktion weiter, die die einzelnen Plots
auf mehrere Seiten verteilt anordnet (in einem 7-zeiligen und 
1-spaltigen Layout):

```{r pdf arrangieren, cache=TRUE}
plots <- lapply(spalten, barcode_plot) %>% 
  marrangeGrob(nrow=7, ncol=1, padding=unit(10, "mm"))
```

Anschließend benutzen wir `ggsave` um die arrangierten Plots in einer
PDF-Datei im DIN A4 Format zu speichern.

```{r pdf speichern, dependson=plots}
ggsave("plots.pdf", plots, width=210, height=297, units='mm')
```


# Extra: Weitere nützliche ggplot Funktionen 

Falls wir noch Zeit am Ende haben, oder zum Weiterüben zu Hause:

**Histogramme** von Variablen verschiedener Gruppen vergleichen:

```{r histogramme}
btw %>%
    ggplot(aes(Alter.unter18, fill=gruppe)) +
    geom_histogram(bins=40) +
    scale_fill_manual(values = mycolors, guide=FALSE) +
    facet_grid(gruppe ~ .)
```

Eine Alternative zu Histogrammen sind **Density-Kurven**:

```{r density kurven, fig.asp=0.7}
btw %>%
    ggplot(aes(Alter.unter18, fill=gruppe)) +
    geom_density(bw=0.2, color=FALSE, alpha=0.8) +
    scale_fill_manual(values = mycolors, guide=FALSE) +
    facet_grid(gruppe ~ .)
```

**Boxplots** sind auch sehr beliebt:

```{r boxplots, fig.asp=0.5}
btw %>%
    ggplot(aes(gruppe, Alter.unter18, fill=gruppe)) +
    geom_boxplot() +
    scale_fill_manual(values = mycolors, guide=FALSE) +
    coord_flip()
```

**Violin Plots** sind eine Mischung aus Boxplot und Density-Kurve:

```{r violin plots, fig.asp=0.5}
btw %>%
    ggplot(aes(gruppe, Alter.unter18, fill=gruppe)) +
    geom_violin(bw=0.2, color=FALSE, alpha=0.8) +
    scale_fill_manual(values = mycolors, guide=FALSE) +
    coord_flip()
```

