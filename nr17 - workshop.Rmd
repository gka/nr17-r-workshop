---
title: "Workshop: Statistische Daten und Wahlergebnisse als Bar-Codes visualisieren"
output:
  html_document: default
  html_notebook: default
---

Hallo, willkommen bei diesem Workshop.

## Worum geht es hier?

Es geht darum die Software R-Studio zu benutzen um Datensätze einzulesen, zu analysieren und zu visualisieren.

Viele Sachen die wir heute machen, kann man genauso gut auch in Excel machen. Mit Pivottabellen und `VLOOKUP()`. Und wer schon einigermaßen Erfahrung mit Excel hat, ist vermutlich sogar schneller als mit R.

Und leider muss ich gleich zu Beginn die Erwartunen etwas dämpfen: Denn was wir mit Sicherheit nicht im Rahmen einer Stunde schaffen werden ist das jeder von Euch R lernt und am Ende ohne weiteres mit R visualisieren kann.

Ich glaube einfach nicht das lernen so funktioniert, weil ich und viele andere die ich kenne selbst nicht so gelernt haben.

Meine Ansicht ist, der einzige Weg etwas zu lernen ist, es selbst für die Arbeit zu benutzen. Und was ich mir mit dieser Stunde erhoffe zu erreichen erreichen ist, euch dafür zu motivieren diese Extrazeit zu investieren.

Wie ich im Vortrag heute morgen schon erzählt habe, habe ich etwa fünf Stunden gebraucht um diesen Code zu schreiben, von der Idee zur Visualisierung bis hin zum tatsächlichen Bild. Und lieber wäre mir, ich hätte auch einen vollen Tag Zeit, den Code zu erklären.

Aber da wir die Zeit leider nicht haben, werde ich nicht auf jeden einzelnen Punkt eingehen können. Weiterhin nehme ich in diesem Workshop an, das ihr R und RStudio schon einmal benutzt hab, und werde nicht das Programm und die einzelnen Funktionen erklären.

Keine Angst, niemand muss hier schnell mitschreiben.

## Was unser Script machen soll:

1. Lade die Wahlergebnisse der letzten Bundestagswahl
2. Berechne die Gesamtstimmen der beiden (willkürlich ausgewählten) Blöcke: Schwarz-Gelb und Rot-Rot-Grün
3. Berechne die prozentualle Stimmendifferenz der beiden Blöcke
4. Identifiziere Gruppen von Wahlkreise mit mehr als 10% Stimmendifferenz
5. Visualisiere Wahlkreisstrukturdaten zu den Gruppen

## Pakete laden

```{r, echo=FALSE}
# install.package('needs')
# library(needs)
```

## 1. Daten laden

Zum laden der Daten benutzen wir das `readr` Package. readr stellt eine ganze Reihe von Befehlen bereit.

```{r}
needs(readr, dplyr)
```

Zunächst werden wir die (zuvor bereinigten) Wahlergebnisse laden. Dazu benutzen wir die `read_tsv` Funktion vom `readr` Paket. Wir speichern das Ergebnis in der Variable `btw`.

```{r}
btw <- read_tsv('data/cleaned/btw09_kerg.csv')
```

**Tipp:** oben rechts im "Environment" Panel zeigt RStudio alle angelegten Variablen und Tabellen. Per Klick lässt sich unsere Tabelle `btw` anschauen.

```{r}
btw <- read_tsv('data/cleaned/btw09_kerg.csv') %>% 
  select(Nr, Wahlkreis, Land,
         CDU=CDU.Zweitstimmen,
         SPD=SPD.Zweitstimmen,
         CSU=CSU.Zweitstimmen,
         FDP=FDP.Zweitstimmen,
         GRÜNE=GRÜNE.Zweitstimmen,
         LINKE=`DIE LINKE.Zweitstimmen`)
```

**Tipp:** Mit der Hilfefunktion in RStudio können wir mehr über alle Befehle erfahren. Dazu einfach den Eingabe-Cursor irgendwo auf das Wort "select" setzen und die F1 Taste drücken.

## 2. Stimmen der beiden politischen Blöcke berechnen

Um neue Spalten zu berechnen benutzen wir das Paket `dplyr` (Link für später: [Introduction to dplyr](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html))

Aus den Zweitstimmen der großen Parteien berechnen wir nun die Gesamtstimmen zweier Blöcke: SPD + LINKE + GRÜNE (RRG) sowie Schwarz-Gelb (SG)

Gesamtstimmen der Koalitionen Rot-Rot-Grün (RRG) und CDU/CSU+FDP (SG) berechnen:
  
```{r}
btw_koal <- btw %>%
  mutate(RRG=SPD + GRÜNE + LINKE,
         SG=CDU + CSU + FDP)
```

Schauen wir uns das Ergebnis an fällt auf das wir immer nur `NA` bei Schwarz-Gelb erhalten. Woran liegt das?

CDU uns CSU sind niemals gleichzeitig definiert. Was wir brauchen ist eine Funktion die automatisch entweder den CDU oder CSU Wert benutzt, je nach dem welcher definiert ist. Die `coalesce` Funktion macht genau das:

```{r}
btw_koal <- btw %>%
  mutate(RRG=SPD + GRÜNE + LINKE,
         SG=coalesce(CDU, CSU) + FDP)
```


# 3. Prozentuale Stimmendifferenz berechnen:
  
1. margin = `100 * (SG - RRG)/(SG + RRG)`
2. sieger
3. landslide, wenn margin 10 Prozent oder mehr
4. klasse

```{r}
btw_margin <- btw_koal %>% 
  # lege ein neues feld "margin" an
  mutate(margin=round(100 * (SG - RRG)/(SG + RRG), 2)) %>% 
  # lege ein neues feld "winner" an
  mutate(winner=ifelse(SG > RRG, 'SG', 'RRG')) %>% 
  # lege ein neues feld "landslide" an
  mutate(landslide=abs(margin) >= 10) %>% 
  # lege ein neues feld "gruppe" an
  mutate(gruppe=paste0(ifelse(landslide,'L_','C_'), winner)) %>% 
  # sortiere die gruppen
  mutate(gruppe=factor(gruppe, c('L_SG', 'C_SG', 'C_RRG', 'L_RRG'))) %>% 
  # entferne ein paar spalten
  select(-CDU, -CSU, -FDP, -SPD, -LINKE, -GRÜNE)
```

kjkjk

```{r}
table(btw_margin$landslide)
table(btw_margin$landslide, btw_margin$winner)
```

Wiederholen mit Wahlergebnissen früherer Wahlen!

## 4. Mit Strukturdaten kombinieren

Strukturdaten dazuladen und per left_join verbinden:
  
```{r}
btw_struktur <- read_tsv('data/cleaned/btw13_strukturdaten.csv') %>%
  select(-Wahlkreis) %>% 
  filter(Nr < 300)
```

und per `left_join` verbinden
  
```{r}
btw_final <- btw_margin %>% 
  left_join(btw_struktur, by ='Nr')
```

## 5. Visualisierung

```{r}
needs(ggplot2)
theme_set(theme_minimal())
```


```{r}
plot_data <- btw_final %>%
  select(landslide, gruppe, wert=Mit.Hochschulreife)

plot_data %>% 
  ggplot(aes(x=wert, y=gruppe, color=gruppe)) +
  geom_point()
```

Mit `scale_colour_manual` können wir unsere eigenen Farben auswählen:

```{r}
colors <- c(L_SG='#333333', C_SG='#777777', L_RRG='#cc0000', C_RRG='#dd7777')

plot_data %>% 
  ggplot(aes(x=wert, y=gruppe, color=gruppe)) +
  geom_point() +
  scale_colour_manual(values = colors)
```


### Bar-Codes

Statt `geom_point` benutzen wir nun `geom_vline`.

```{r, fig.height=2, fig.width=8}
plot_data %>% 
  ggplot() +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.35) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10()
```

Mit `facet_grid` kann man aus jedem Plot ganz einfach Small multiples machen:

```{r, fig.height=3, fig.width=8}
plot_data %>% 
  ggplot() +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.35) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10() +
  facet_grid(gruppe ~ .)

# introduction: facet_grid
#  gruppe ~ .    . ~ gruppe    landslide ~ sieger
```


Nur "landslide" Wahlkreise:

```{r, fig.height=2, fig.width=8}
plot_data %>% 
  filter(landslide) %>% 
  ggplot(aes(wert)) +
  facet_grid(gruppe ~ .) +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.35) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10()
```

Mittelwerte hinzufügen:

```{r, fig.height=2, fig.width=8}
mittel <- plot_data %>% 
  group_by(gruppe) %>% 
  summarize(avg=mean(wert), med=median(wert))

plot_data2 <- left_join(plot_data, mittel, 'gruppe')

plot_data2 %>% 
  filter(landslide) %>% 
  ggplot() +
  facet_grid(gruppe ~ .) +
  geom_vline(aes(xintercept=wert, color=gruppe), size=1.5, alpha=0.25) +
  geom_vline(aes(xintercept=avg), color='black', size=2, alpha=1) +
  scale_colour_manual(values = colors, guide=F) +
  scale_x_log10()
```

das ganze können wir in einer funktion speichern:

```{r, fig.height=3, fig.width=8}
plot_bars <- function(spalte, log=FALSE) {
  
  plot_data <- btw_final %>% 
    filter(landslide) %>% 
    select_('winner', 'gruppe', wert=as.name(spalte)) %>% 
    mutate(wert=wert)

  mittel <- plot_data %>% 
    group_by(gruppe) %>% 
    summarize(avg=mean(wert), med=median(wert))
  
  plot <- plot_data %>% 
    left_join(mittel, 'gruppe') %>% 
    ggplot(aes(wert)) +
    facet_grid(gruppe ~ .) +
    geom_vline(aes(xintercept=wert + rnorm(nrow(plot_data), sd = 0.1), color=gruppe), size=1.5, alpha=0.25) +
    geom_vline(aes(xintercept=avg), color='white', size=5, alpha=0.7) +
    geom_vline(aes(xintercept=avg), color='black', size=1, alpha=1) +
    scale_colour_manual(values = colors, guide=F) +
    ggtitle(spalte) + xlab('')
    theme(plot.margin = rep(unit(0.5,'cm'),4))
  
  if (log) plot <- plot + scale_x_log10()
  plot
}
```


```{r, fig.height=2, fig.width=8}
# plot_bars('Bevölkerungsdichte', log=TRUE)
plot_bars('Mit.Hochschulreife')
```

und lassen die funktion automatisch über alle Spalten in unserem Datensatz laufen. Das Ergebnis speichern wir als PDF Datei mit je 7 Plots pro Seite:

```{r}
needs(gridExtra)

plots <- lapply(colnames(btw_final)[10:47], plot_bars)
plots <- marrangeGrob(plots, nrow=7, ncol=1)
ggsave("plots.pdf", plots, width=21, height=27.9, units='cm')
```
